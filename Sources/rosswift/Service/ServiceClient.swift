//
//  ServiceClient.swift
//  RosSwift
//
//  Created by Thomas Gustafsson on 2018-10-24.
//

import Foundation
import StdMsgs
import RosTime
import NIO

enum ServiceError: Error {
    case invalidInput(String)
    case noResponse
}

internal final class ServiceClient {

    internal var impl_ : Impl?

    private init() {}

    init(name: String, md5sum: String, persistent: Bool = false, header_values: M_string? = nil) {
        let impl = Impl(name: name, md5sum: md5sum, persistent: persistent, header: header_values)
        impl_ = impl
        if persistent {
            impl_?.server_link_ = ServiceManager.instance.createServiceServerLink(service: impl.name_, persistent: impl.persistent_, request_md5sum: impl.service_md5sum_, response_md5sum: impl.service_md5sum_, header_values: impl.header_value_)
        }
    }

    func call<MReq: ServiceMessage, MRes: ServiceMessage>(req: MReq) -> EventLoopFuture<MRes?> {
        if MReq.srv_md5sum != MRes.srv_md5sum {
            fatalError("The request and response parameters to the service " +
                "call must be autogenerated from the same " +
                "server definition file (.srv). your service call " +
                "for \(impl_?.name_ ?? "no name") appeared to use request/response types " +
                "from different .srv files. (\(MReq.srv_md5sum) vs. \(MRes.srv_md5sum)")
        }
        let ser_req = SerializedMessage(msg: req)
        return call(req: ser_req, service_md5sum: MReq.srv_md5sum).map { (sm) -> MRes? in
            do {
                let res : MRes = try deserializeMessage(m: sm)
                return res
            } catch {
                ROS_ERROR("Exception thrown while while deserializing service call: \(error)")
                return nil
            }
        }
    }

   func call(req: SerializedMessage, service_md5sum: String) -> EventLoopFuture<SerializedMessage> {

        let eventLoop = thread_group.next()
        let promise : EventLoopPromise<SerializedMessage> = eventLoop.newPromise()

        guard let impl = impl_, impl.service_md5sum_ == service_md5sum else {
            let err = ServiceError.invalidInput("Call to service [\(impl_!.name_)] with md5sum [\(service_md5sum)] does not match md5sum when the handle was created ([\(impl_!.service_md5sum_)])")
            promise.fail(error: err)
            return promise.futureResult
        }
        var link : ServiceServerLink?

        if impl.persistent_ {
            if impl.server_link_ == nil {
                impl.server_link_ = ServiceManager.instance.createServiceServerLink(
                    service: impl.name_,
                    persistent: impl.persistent_,
                    request_md5sum: service_md5sum,
                    response_md5sum: service_md5sum,
                    header_values: impl.header_value_)

                if impl.server_link_ == nil {
                    promise.fail(error: ServiceError.invalidInput("Could not create ServiceServerLink"))
                    return promise.futureResult
                }
            }
            link = impl.server_link_
        } else {
            link = ServiceManager.instance.createServiceServerLink(
                service: impl.name_,
                persistent: impl.persistent_,
                request_md5sum: service_md5sum,
                response_md5sum: service_md5sum,
                header_values: impl.header_value_)
            if link == nil {
                promise.fail(error: ServiceError.invalidInput("Could not create ServiceServerLink"))
                return promise.futureResult
            }
        }
        promise.succeed(result: SerializedMessage())

        return link!.call(req: req)
    }



    func isValid() -> Bool {
        return impl_?.isValid() ?? false
    }

    func isPersistent() -> Bool {
        return impl_?.persistent_ ?? false
    }

    func shutdown() {
        impl_?.shutdown()
    }

    func waitForExistence(timeout: RosTime.Duration = RosTime.Duration(seconds: -1)) -> Bool {
        guard let impl = impl_ else {
            return false
        }

        return service.waitForService(service_name: impl.name_, timeout: timeout)
    }

    func exists() -> Bool {
        guard let impl = impl_ else {
            return false
        }
        return service.exists(service_name: impl.name_, print_failure_reason: false)
    }

    func getService() -> String {
        return impl_?.name_ ?? ""
    }

}
